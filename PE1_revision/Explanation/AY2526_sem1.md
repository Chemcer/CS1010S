# Question 1

## Script design

No converting int to string but can use character counting as an inspiration (check 1st or last char and start slicing)

Slicing is equivalent to floor div 10 and comparison is between the remainder of floor div 10 and digit

Why not check the last digit to the one place? Simply because it is annoying to deal with, you have to find an appropriate floor division and modulo base

## The code

<details>
<summary><b>Solution using divmod</b></summary>

```python
def digit_copies(n, m, digit):
    res = 0
    for num in range(n, m+1):
        if num !=0:
            num, rem = divmod(num,10)
            if rem == digit:
                res += 1
    return res
```

</details>

divmod returns (result, remainder), this is equivalent to 

<details>
<summary><b>Solution without divmod</b></summary>

```python
def digit_copies(n, m, digit):
    res = 0
    for num in range(n, m+1):
        while num != 0:
            if num%10 == digit:
                res += 1
            num = num//10
    return res
```

</details>

# Question 2

## Script design and sub-problems

Count the 1st char, remove all instances and put the result at the back, returns a value if the digit is <= 9

### Counting char 

The usual way is to check slice check slice check slice

<details>
<summary><b>Character counting algorithm</b></summary>

```python
def count_times(s, c):
    if s == "":
        return 0
    first_chr = s[0]
    remaining = s[1:]
    if first_chr == c:
        return 1 + count_times(remaining, c)
    else:
        return count_times(remaining, c)
```

</details>

or just use string methods `s.count(s[0])`, which is the easier

### Removing characters

Same thing, check slice check slice.... Since we are removing characters, we have to check if the 1st(or last) character is the character we want to remove

<details>
<summary><b>Removing character algorithm</b></summary>

```python
def remove_chr(s, c):
    if s == "":
        return s
    first_chr = s[0]
    remaining = s[1:]
    if first_chr == c:
        return remove_chr(remaining, c)
    else:
        return first_chr + remove_chr(remaining, c)
```

</details>

or just use string methods `s.replace(s[0], "")`, which is easier 

## Final code

As mentioned in the question, we count the number of characters == s[0], put it at the end of the string, repeat until you have a string of the same numbers and length is less than 10

<details>
<summary><b>Solution</b></summary>
 
```python
def get_second_key(s):
    c = s[0]
    remaining = remove_chr(s, c)
    n = count_times(s, c)
    if remaining == "" and 0 < n <= 9:
        return n
    return get_second_key(remaining + str(n))
```

</details>

## Final code using string methods

Honestly, making the text disappear was pretty confusing to me so I made this

Entire idea of the problem is to repeat counting and removing then return a value between 1 and 9, both inclusive

This is my solution to the qn

<details>
<summary><b>Solution</b></summary>
 
```python
def temp(s):
    count = s.count(s[0]) # count the occurance of 1st character
    return s.replace(s[0], "") + str(count) # delete all occurance of 1st character and concatenate the count at the back
    
def get_second_key(s):
    if len(s) == s.count(s[0]) and len(s)<=9: # check if the digits are the same and is less than 10
        return int(temp(s)) # the "key"
    return get_second_key(temp(s))
```

</details>