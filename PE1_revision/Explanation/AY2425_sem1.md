# Q1

## Script design and sub problems

Pretty similar to AY2526 q1 where we are cutting the number using floor div

### Sub prob 1: How do we check if sub seq is in main seq

Ans: if we run main_seq%base, it is essentially checking for the existance of sub seq

### Sub prob 2: What is the base

Ans: Of course it has to be 10 smth, the exponent can be found by finding the length of sub seq by floor divide 10 repeatedly

By answering the above sub problems, we can then create a helper function to deal with this

### Finding modulo base

If we floor div repeatedly, it will eventually hit 0

```
def temp(num):
    power = 0
    while num != 0:
        num = num//10
        power += 1
    return power
```

## Final code

Use floor div 10 to remove the last number and check with sub_seq

For efficiency sake, we can stop the moment main_seq < sub_seq

```
def count(main_seq, sub_seq):
    res = 0
    div = 10**temp(sub_seq)
    while main_seq >= sub_seq:
        if main_seq%div == sub_seq:
            res+=1
        main_seq =  main_seq//10
    return res
```

# Q2

## Script design

Notice that it is s1[:k] getting concatenated then switch to s2[:k]

This hints that the return statement should call the function with the position of s1 and s2 swapped

Of course, rememer to slice the string when calling the function

Remember that there is no index issue when slicing so our base case can just be len of s1 and s2 = 0

## Final code

```
def interleave(s1, s2, k):
    if len(s1)==0 and len(s2)==0:
        return ""
    return s1[:k] + interleave(s2, s1[k:], k)
```


