# Q1 MCQ

## Part A

```python
a = 'book'
b = 'books'
c = 'shelf'
if a < b:
    if <condition 1>:
        print(a)
    else:
        print(c)
if a > c:
    print(a)
elif <condition 2>:
    print(c)
```

```pycon
book
shelf
```

For string comparisons, we can go based on alphabetical order then lower > upper case

The output book must come from the 1st if block because 2nd if block condition is false. Condition 1 must then be a < c or b < c

Shelf comes from the final elif. As such, we find a condition that is true, which is a < b

## Part B

```python
def fun(t, n):
    c = ()
    for i in range(0, n, 1):
        if i%2 == 0:
            c = c + t[i:len(t):1]
        else:
            c = c + (t[i], )
    return c

fun((1, 2, 3, 4, 5, 6), 10)
```

Line 2 is not an issue because we are iterating through different values of i from 0 to 9

Line 4 is not an issue because tuple slicing does not raise index error

Line 6 is an issue because it will raise index error when i>=6

## Part C

```python
y = 2
def f(x):
    y = x + 2
    return y
def g(y):
    y = y + 1
    return y
x, y = 3, 3
x = f(y)
y = g(x)

print(x, y)
```

The 1st y=2 line is rather pointless. Main focus for this question is at x, y = 3, 3

When x = f(y) it is essentially f(3). f(3) returns 3 + 2 = 5

When y = g(x), note that x is referencing the value 5 now, so y = g(5) = 6

So x, y is 5 6

# Q2 Code Tracing

## Part A

```python
def foo(s):
    if s=='':
        return 'Done'
    t=int(s[0]) * 2+int(s[-1])
    foo(s[1 : len(s) : 1])
    print(t)

print(foo("12345"))
```

foo('12345') --> t = 1 * 2 + 5 = 7 call foo('2345') --> t = 2*2 + 5 = 9 call foo('345') --> .... --> foo('5') --> t = 5*2 + 5 = 15 call foo('') return 'Done' --> reverse the entire thing and print value of t.

Note that foo('12345') does not return anything so it returns None. 

```pycon
15
13
11
9
7
None
```

## Part B

```python
i=0
while i<10:
    for j in range(1, i- 1, 1):
        if i%2==0:
            continue
    print(i, j)

    if i<=5:
        i=i+1
        continue
    print(i, j)
    break
```

Notice there i = 0 to 2 does not enter for loop because there is no number in that range, for loop does not do anything when i is even, and breaks when i = 6

i = 3 --> j = 1 --> print(3, 1) --> i = 4 --> next iteration 

i = 4 --> nothing interesting --> i = 5

i = 5 --> j = 1 to 3 --> print(5, j) --> i = 6

i = 6 --> nothing interesting aside from j = 4 --> print(6, 4) --> break

```pycon
3 1
5 1
5 2
5 3
6 4
```

# Q3 Debugging

## Part A

```pycon
>>> nth_digit(1, 12345)
5
>>> nth_digit(3, 12345)
3
>>> nth_digit(4, 12345)
2
```

Based on python console output, we are checking the nth digit from the right.

We can definitely stop the function at n = 1 because we can then take num%10 to get the answer

To check the next digit and update the n accordingly, we can take num//10 and n-1

The answer is just

```python
def nth_digit(n, num):
    if n == 1:
        return num%10
    else:
        return nth_digit(n-1, num//10)
```

## Part B

In the above function, if n is greater than number of digits, the function will just return 0. Question wants it to return None instead

Notice that we can just add `if n > len(str(num))` to check number of digits because there is no restriction on data type.

If there is a restriction, we need to consider the fact that num must not be 0 at the base case and we can return None the moment num hits 0 during the recursion

```python
if n == 1 and num > 0:
    return num%10
if num == 0:
    return None
```

# Q4 Powerset

This is tutorial 5 lol

## Part A

To convert decimal to base, it always follow decimal%base and decimal//base. 

To illustrate decimal//base, decimal = $\sum_{n=0} a_n base^{n}$, when applying a floor division, it changes n to n-1 and removes the $a_0 base^0$ term

Example, 12 in binary is $1 \cdot 2^3 + 1 \cdot 2^2 + 0 \cdot 2^1 + 0 \cdot 2^0$, by floor dividing 2, it becomes 6 and $1  \cdot 2^2 + 1 \cdot 2^1 + 0 \cdot 2^0$ --> floor div 2 --> 3 $1 \cdot 2^1 + 1 \cdot 2^0$ --> floor div 2 --> 1 $1 \cdot 2^0$

The python script is then 

```python
def decimal_to_base_n(val, n):
    conv="0123456789abcdef"
    res="" 
    if val==0:
        return "0"
    while val>0:
        res=conv[val%n]+res
        val=val//n
    return res
```

## Part B

The given partial code is 

```python
def n_queens(n):
    for i in range(_____, _____, _____):
        b= __________________________
        b="0" * (_____________)+b

        if no_threats(b):
            return b
        
    return ""
```

Notice that we can represent the position using numbers and the size of grid is also the same as the base

To consider all placement in the grid, the iteration must go until "nnn....n" which is suggest `for i in range(n**n)`. $n^n$ because the conversion excludes $1 \cdot base^{n+1}$

b is then the conversion of i to whatever the size of grid is. Followed by a zfill for padding to get length equal to grid length

```python
def n_queens(n):
    for i in range(0, n**n, 1):
        b = decimal_to_base_n(i, n)
        b = '0' * (n - len(b)) + b
        if no_threats(b):
            return b
```