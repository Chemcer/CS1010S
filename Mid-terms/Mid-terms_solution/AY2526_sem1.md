# Q1 Code Tracing

## Part (a)

```python
x, y = 7, 3

def a(x):
    return y + b(x)

def b(y):
    if y < 6:
        print(x - y)
        return x - y
    else:
        print(y - x)
        return y - x

x = a(8)
y = a(b(x))
print(y)
```

The first line is just referencing x and y to some values. You will need them when executing functions because y in a(x) is not defined inside the function (uses global y) and x in b(y) is again not defined inside the function (uses global x)

x = a(8) exeucutes a(8) then x changes its reference the value of what a(8) returns. 

Execution of a(8): 3 (val of y in line 1) + b(8) --> 8 >= 6 so 8 - 7 = 1 --> prints 1 and x is referencing the value 1.

Repeat the same process for y = a(b(x)). Since x is now 1, y = a(b(1)). b(1) --> 1 < 6 --> 1 - 1 = 0 print and return 0. a(0) --> 3 (1st line) + b(0). b(0) --> 1 - 0 = 1, print and return 1. a(0) returns 4. y is now referencing the value 4

Lastly, print y which is 4 since

```pycon
1
0
3
4
```

## Part (b)

```python
def pingpong(n):
    if n<6:
        return n
    else:
        return pongping(n) + pingpong(n-1)
        print(n)

def pongping(n):
    if n<7:
        return n
    elif (n-1) % 3 == 0:
        print((n-1) % 3)
        return -1 * pongping(n-1)
    else:
        print(n)
        return -1

print(pingpong(9))
```

It is a bunch of recursion. Note that pingpong else statement has a return before print, the print(n) is never executed

pingpong(9) calls pongping(9) + pingpong(8)

Focusing on pongping(9), (9-1)%3!=0. pongping(9) --> print 9 return -1. Yey it is not too bad

Focusing on pingpong(8). pingpong(8) --> calls pongping(8) + pingpong(7) 

(8-1)%3!=0. pongping(8) --> print 8 return -1

pingpong(7) --> calls pingpong(6) + pongping(7)

(7-1)%3==0. pongping(7) --> print 0 calls -1*pongping(6) --> pongping(6) returns 6. pongping(7) returns the value -6

pingpong(6) calls pingpong(5) + pongping(6) --> 5 + 6

We have reached base case, it is time to pop all the stacks

pingpong(7) = 11-6 = 5

pingpong(8) = 5 - 1 = 4

pingpong(9) = 4 - 1 = 3

```pycon
9
8
0
3
```

## Part (c)

```python
def count():
    for i in range(1, 5, 1):
    total, j = 0, i
    while j <= 4:
        j = j+1
        total += j
        if j%2 == 0:
            continue
        print(total)
    if i%3 == 0:
        i = i+1
        break

print(count())
```

Pretty much looking through each iteration. The i = i + 1 in the if block is rather pointless because we are just breaking the loop.

i = 1 --> j = 1 --> enter while loop --> j = 2 total = 2 since 2%2==0, go to next while loop iteration --> j = 3 total = 5 print 5 --> j = 4 total = 9 --> j = 5 total = 14 print 14. Exit while loop enter next for loop iteration

i = 2 --> total = 0 and j = 2 --> j = 3, total = 3 print 3 --> next while loop iteration --> j = 4 total = 7 --> j = 5, total = 12 print 12. Exit while loop and enter the next for loop iteration

i = 3 --> total = 0 and j = 3 --> j = 4, total = 4 --> j = 5, total = 9 print 9. exit while loop --> it meets the condition i%3 == 0, break the loop. Function ends here and returns None because there is no return statement

```pycon
5
14
3
12
9
None
```

# Q2

## Part A

```python
def foo(num):
    res = ''
    if 0 < num < 10 and num % 2 == 0:
        res = res + 'C'
    else:
        if 10 < num < 20 and num % 2 == 0:
            res = res + 'C'
    res = res + 'S'
    return res
```

### Part 1

If we want an output 'C', it is impossible because result must have the character 'S' in it (2nd last line)

### Part 2

We want an output 'S' only, no 'C' in it. Check the condition to see how we can avoid res = res + 'C'. Notice that the condition excludes 10, 20 and odd numbers. Hence, the answer can be 10, 20 or an odd number between 1 and 20 inclusive.

### Part 3

As mentioned in part 2, it excludes odd numbers, 0, 10 and 20. We can rewrite this to... (there can be several variants, just ensure that the logic checks out and no syntax error)

```python
def foo(num):
    res = ''
    if 0 < num < 20 and num != 10 and num % 2 == 0:
        res = res + 'C'
    res = res + 'S'
    return res
```

## Part B

```python
def tuple_fun(t, n):
    res = ()
    for i in range(0, len(t), 1):
        for j in range(i, n, 1):
            res += (t[j],)
    return res
```

### Part 1

To find tuple t and n such that it does not raise any error, we can either not enter the 1st for loop at all or ensure the 2nd for loop end point is less or equal than 1st for loop.

So as the answer key mentions, either an empty tuple and any n or non empty tuple and n>=len(t).

### Part 2

Once the logic to execute the code without error has been found, finding ways to raise an error is simple as we take the negation of part 1. One of the criterias in part 1 is n>=len(t), so choose any n < len(t). 

# Q3 Debugging 

```python
def sub_seq(string1, string2, m, n):
    if m == 0:
        return False
    if n == 0:
        return True
    if string1[m-1] == string2[n-1]:
        return sub_seq(string1, string2, m - 1, n)
    return sub_seq(string1, string2, m, n - 1)
```

Firstly, understand what a subsequence is, which is mentioned in the question.

Secondly, understand the overall idea of the code in the question. Side note, this is a variation of a double pointer technique.

Since we are checking if string1 is a subsequence of string 2, and the code wants to check based on the last character of string 1.

To contextualise, the ideal execution based on last character checking, I will be using cs and c10s10.

Last char of cs10s10 is not s --> reduce index of string2 by 1 --> 2nd last char of cs10s10 is not s --> reduce index of string2 by 1 --> 3rd last char of cs10s10 is s --> check for c by reducing index of cs + reduce the index of cs10s10 by 1 to check the next char--> ...

When there is a 0, we have checked the entire string (both 1 and 2). Since the algorithm checks if string 1 is a subsequence, index of string1 will hit 0 first if it is a subsequence of string2.

Based on the logic above, we know that m is 0, it is a subsequence so the error must be at lines 3 and 5. Swap the 2 lines and change the last line to m-1 the algorithm is correct

# Q4 Writing Code

## Part A, Encryption

The question is titled peeling an onion which is kind of a hint for this question.


Notice that the encryption follows something like 1st + last + 2nd + 2nd last + ..., it ends when we reach the "center" of the digit. Rmb to apply helper to each digit and it can only take in 1 digit

Based on the above logic, and nature of helper function,

Base case, `len(msg) < 2` because helper is applied to every digit and stops at the center.

Else statement, helper 1st + helper last + msg[1:-1] (slice the msg/"peeling")

## Part B, Decryption

Reverse the encryption logic. We can reverse the helper function by applying another helper. The encryption pattern is 1st, last, 2nd, 2nd last,...

So when decrypting the digit, we can write 1st digit + remove first digits + 2nd digit